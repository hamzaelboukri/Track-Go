Contexte du projet
1. Contexte du Projet
"KoliGo" est une solution mobile destinée aux entreprises de transport express pour la gestion du "dernier kilomètre". Dans une industrie où la précision et la traçabilité sont vitales, cette application doit permettre aux livreurs de gérer leur tournée de manière fluide, tout en fournissant des preuves de livraison incontestables (géolocalisation, scan, photos).

L'objectif de ce sprint de 2 semaines est de passer d'une idée à une application robuste et performante, capable de gérer les conditions réelles du terrain (erreurs de scan, incidents).

2. Objectifs d'apprentissage
À l'issue de ce projet, les apprenants auront acquis des compétences en React Native :

Maîtriser le Design System mobile (Flexbox, SafeAreas, Typographie responsive).
Optimiser le rendu de listes dynamiques massives via FlatList (mémorisation, getItemLayout).
Implémenter une architecture de navigation hybride complexe (Auth Flow -> Tabs Flow -> Stacks imbriquées).
Gérer un état d'application persistant et synchronisé entre plusieurs écrans.
Vision par ordinateur : Intégration fine de la caméra pour le scan de codes-barres 1D/2D avec gestion des conditions de faible luminosité.
Système de Géolocalisation : Monitoring de la position en arrière-plan et visualisation sur cartes interactives (react-native-maps).
Capture Médias : Gestion de l'appareil photo pour les preuves de livraison / rapports d'incidents
Consommer des données via des services asynchrones (REST/JSON-Server).
3. User Stories
US1 : Auth & Session : En tant que livreur, je veux m'identifier de manière sécurisée pour accéder à mes tournées personnelles.
US2 : Tableau de Bord interactif : En tant que livreur, je veux voir l'avancement global de ma tournée sous forme de liste et de carte.
US3 : Validation par Scan Intelligent : En tant que livreur, je veux scanner le code du colis pour confirmer la remise, avec une vérification d'ID.
US4 : Preuve de Livraison Géo-certifiée : En tant que livreur, je veux que ma position soit enregistrée lors de la validation pour certifier mon passage.
US5 : Gestion d'Incident Complexe : En tant que livreur, je veux pouvoir signaler un problème (Destinataire absent/Colis endommagé) avec une photo et un commentaire.
4. Plan de Développement (2 semaines)
Semaine 1 : Fondations, UI et Listes
Jour 1-2 : Setup environnement (TypeScript, Expo, Android Studio/Emulator or Expo GO), Navigation (Expo Router).
Jour 3-4 : Écran "Ma Tournée". Implémentation de la FlatList avec des données mockées complexes. Design des cartes de colis.
Jour 5 : Écran Détail du colis et Navigation Stack. Passage de paramètres et premières interactions simples.
Semaine 2 : Hardware et Logic Avancée
Jour 6-7 : Intégration de expo-camera pour le scan et react-native-maps pour la vue carte.
Jour 8 : Logic de validation. Captures GPS (expo-location) et gestion des changements d'état.
Jour 9 : Gestion des incidents. Formulaires multipages, appareil photo et feedback utilisateur.
Jour 10 : Polissage final, optimisation des performances (JSI), tests sur appareils réels et démonstration.
5. Contraintes Techniques Obligatoires
Langage : TypeScript obligatoire (Typage strict des données colis).
Architecture : Dossiers structurés par components, services, hooks, constants.
Navigation : Utilisation de Expo Router (File-based navigation).
Style : NativeWind ou StyleSheet.
CI/CD : Mise en place d'une GitHub Action qui se déclenche à chaque Pull Request pour vérifier le Linting et le Type-checking (TypeScript) (Bonus: Build).
Docker : Fournir un Dockerfile et un docker-compose.yml pour lancer le serveur de mock API.
6. Architecture des Données & Consommation
Pour garantir une application fluide et réactive, la gestion des données suivra une architecture à trois niveaux :

4.1. Source de Vérité (Remote API)
Outil : Un serveur de mock API lancé via Docker (JSON-Server).
Consommation : Utilisation de fetch ou axios centralisée dans un dossier services/.
Format : Les données reçues doivent être immédiatement typées avec TypeScript pour éviter les erreurs de manipulation.
4.2. État Global & Local (Application State)
Synchronisation : Au lancement, l'application récupère la liste des colis depuis l'API.
Gestion : Utilisation de useState ou useReducer pour gérer l'état local de la tournée (ex: filtrage en temps réel).
4.3. Persistance (Local Storage)
Outil : expo-sqlite ou AsyncStorage.
Rôle : Sauvegarder l'état de la tournée pour éviter la perte de données en cas de fermeture de l'app ou de crash.
Flux : Tout changement de statut (Colis livré) doit être mis à jour sur l'API ET dans le stockage local.
7. Défis Bonus
1. Dark Mode Complet : Adaptation automatique de l'interface et de la carte au thème système.
Statistiques en Temps Réel : Ajouter un onglet "Performance" avec des graphiques (ex: temps moyen de livraison).
Build Automatisé : Utiliser EAS Build avec GitHub Actions pour générer un APK/IPA automatiquement sur un tag de version.
Signature Digitale : Intégrer un canvas de signature (react-native-signature-canvas) pour permettre au client de signer directement sur l'écran du livreur.
Optimisation d'Itinéraire : Calculer et afficher l'ordre optimal de livraison en fonction de la distance entre le livreur et tous les points restants.
Notifications Client Automatiques : Simuler l'envoi d'un SMS ou d'une notification de "proximité" au client lorsque le livreur est à moins d'un kilomètre de l'adresse de livraison.
Optimisation : Les données ne doivent pas être récupérées inutilement ; implémenter un système de rafraîchissement au besoin (Pull-to-refresh).
Livrables
- Repository GitHub propre avec README détaillé (Description de l'architecture d' application, Un guide d'installation et de configuration, ...)
- Jira pour la planification 
- Tests, Docker et Pipelines CI/CD en succès. 
Critères de performance
La structure du projet
Le nommages des dossiers et fichiers principaux
La clarté du code 
DRY principles (Do Not Repeat Yourself): éviter la répétition des fonctions
The Single Responsibility Principle (SRP): une fonction ou méthode à une seule responsabilité ou objectif
Le nommage des fonctions et des variables
La validation des entrées (données)
La gestion des erreurs (Error Handling)
La capacité de comprendre et lire la documentation